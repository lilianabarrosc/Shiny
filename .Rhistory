})
#Obtengo la seleccion de atributos a comparar para la Opcion 3
dat3 <- reactive({
missingV()[input$z3[1]:input$z3[2],input$x3[1]:input$x3[2]]
})
#Option 3 (matricial)
output$missing3 <- renderPlot({
if(is.null(input$x3) || is.na(input$x3)){
return()
}
tryCatch({
scattmatrixMiss(dat3(), interactive = F, highlight = c(names(missingV())[[input$y3]]))
}, error = function(e) {
createAlert(session, "alertMissing3", "alertMissing3ID", title = titleAlert,
content = paste("",e),
style = "warning")
})
})
#************************************************
#-------------> Eliminacion de ruido
#   #Slider visualizacion grafico ruido
#   output$slider_range_range_nremoval <- renderUI({
#     twoSlider("attributes4","observation4",missingV(),"Attributes",strz)
#   })
#   #Se detectan las columnas con ruido
#   columnsNoise <- reactive({
#     if(is.na(noiseR() | is.null(noiseR()))){
#       diffValues <- calculateDiff(missingV())
#       getColumnsNoise(diffValues, input$limitNoise)
#     } else {
#       diffValues <- calculateDiff(noiseR())
#       getColumnsNoise(diffValues, input$limitNoise)
#     }
#   })
noiseR <- reactive({
if(input$rnoise){
diffValues <- calculateDiff(missingV())
columnsNoise <- getColumnsNoise(diffValues, input$limitNoise)
#  columnsNoise <- as.data.frame(columnsNoise[,1] + ncol(missingV()))
as.data.frame(missingV()[,-columnsNoise[,1]])
}
})
#Slider visualizacion grafico parallel x e y
output$slider_range_range_nremoval <- renderUI({
box(
width = 6, status = "success",
h4("Range"),
sliderInput("attributes4", label = strx, min = 1,
max = dim(noiseR())[2], value = c(1, dim(noiseR())[2])),
sliderInput("observation4", label = stry, min = 1,
max = dim(file())[2], value = 2)
)
})
#Slider visualizacion grafico parallel observations y alfa
output$slider_range_range_nremoval2 <- renderUI({
box(
width = 6, status = "success",
h4("Range"),
sliderInput("ZNremoval", label = strz, min = 1,
max = dim(noiseR())[1], value = c(1, dim(noiseR())[1])),
sliderInput("lineSizeNremoval", label = "Line Size", min = 1,
max = 5, value = 2),
sliderInput("alphaLineNremoval", label = "Alpha Line", min = 0.01,
max = 0.99, value = 0.11)
)
})
#   #accion del boton noise removal
#   noiseR <- eventReactive(input$rnoise, {
#     dcolumnsNoise <- as.data.frame(columnsNoise()[,1] + countVariables)
#     dataSet[,-columnsNoise[,1]]
#   })
#seleccion de atributos y observaciones del data set
datNremovalx <- reactive({
noiseR()[input$ZNremoval[1]:input$ZNremoval[2],
input$attributes4[1]:input$attributes4[2]]
})
#seleccion de la variable de respuesta
datNremovaly <- reactive({
file()[,input$observation4]
})
#grafico de ruido
output$nremoval <- renderPlot({
if(is.null(input$attributes4) || is.na(input$attributes4)){
return()
}
myPalette <- c(input$col1, input$col2, input$col3)
# A ParallelPlot of all rows and all columns
withProgress({
setProgress(message = "This may take a while...")
ParallelPlot(datNremovalx(), seq(1,nrow(datNremovalx()),1), seq(1,ncol(datNremovalx()),1), datNremovaly(),
names(file())[[input$observation4]], 1, input$alphaLineNremoval, TRUE, colours = myPalette)
})
})
#Calcular el numero de columnas con ruido
output$columnsNoise <- renderPrint({
tryCatch({
diffValues <- calculateDiff(noiseR())
columnsNoise <- getColumnsNoise(diffValues, input$limitNoise)
paste("Have ", paste(nrow(columnsNoise), " noise columns."))
}, error = function(e) {
createAlert(session, "alertNoise", "alertNoiseID", title = titleAlert,
content = "Missing values in data",
style = "warning")
})
})
#************************************************
#-------------> Local outlier factor
## scores for the original data
outlier.scores <- reactive({
lof(missingV(), k= c(5:10))
})
#Slider visualizacion grafico de missing VIM option2
output$sliderLOF <- renderUI({
minimo <- round(min(outlier.scores()), digits=2)
maximo <- round(max(outlier.scores()), digits=2)
sliderInput("thresholdt", "Threshold", min = minimo,
max = maximo, value = 1.25, step= 0.01)
})
#llamado a la funcion lof, la cual devuelve una lista
res <- reactive({
if(is.na(outlier.scores()) && is.null(outlier.scores())){return}
else{
if(!is.null(input$thresholdt)){
LOFCraft(data = missingV(), threshold = input$thresholdt, data.frame(outlier.scores())) ##calling LOF
} else {
LOFCraft(data = missingV(), data.frame(outlier.scores())) ##calling LOF
}
}
})
## scores for the without outliers data
withoutOutliers.scores <- reactive({
data.frame(res()[1]) ## scores of data without outliers
})
#grafico inicial density plot
output$densityPlot <- renderPlot({
tryCatch({
if(input$rnoise){
withProgress({
setProgress(message = "This may take a while...")
DensityPlot(data.frame(outlier.scores()), ncol(data.frame(outlier.scores())))
})
}
else{missingV()}
}, error = function(e) {
createAlert(session, "alertlof1", "alertlof1ID", title = titleAlert,
content = paste("",e),
style = "warning")
})
})
#Grafico resultante tras realizar corte del primer density
output$densityPlotResult <- renderPlot({
tryCatch({
if(input$rnoise){
withProgress({
setProgress(message = "This may take a while...")
DensityPlot(withoutOutliers.scores(), ncol(outlier.scores())) #Generating a plot of outliers scores
})
}
else{missingV()}
}, error = function(e) {
createAlert(session, "alertlof2", "alertlof2ID", title = titleAlert,
content = paste("",e),
style = "warning")
})
})
#Cantaidad de outlier existentes
output$howManyOutliers <- renderPrint({
as.numeric(res()[3])
})
#Posicion de los outlier en el archivo
output$posOutliers <- renderPrint({
data.frame(res()[4])  ## the positions of the outliers in the original data and theirs respective scores
})
#without outliers data
output$strWithoutOutliers <- renderPrint({
dataWithoutOutliers<-data.frame(res()[2])  ##the data without outliers
str(dataWithoutOutliers)
})
#************************************************
#-------------> Normalization
#salida dinamica de rango para normalizacion
output$range <- renderUI({
if (is.null(input$normalizationType))
return()
switch(input$normalizationType,
'2' =  tags$div( class = 'col-sm-8',
tags$div( class = 'col-sm-4',
numericInput("min", label = "Min", value = 0)
),
tags$div( class = 'col-sm-4',
numericInput("max", label = "Max", value = 1)
)
),
'3'= tags$div( class = 'col-sm-8',
selectInput("type_normalization", label = "Other normalization",
choices = list("without normalization" = "n0",
"standardization ((x-mean)/sd)" = "n1",
"positional standardization ((x-median)/mad)" = "n2",
"unitization ((x-mean)/range)" = "n3",
"positional unitization ((x-median)/range)" = "n3a",
"unitization with zero minimum ((x-min)/range)" = "n4",
"normalization in range <-1,1> ((x-mean)/max(abs(x-mean)))" = "n5",
"positional normalization in range <-1,1> ((x-median)/max(abs(x-median)))" = "n5a",
"quotient transformation (x/sd)" = "n6",
"positional quotient transformation (x/mad)" = "n6a",
"quotient transformation (x/range)" = "n7",
"quotient transformation (x/max)" = "n8",
"quotient transformation (x/mean)" = "n9",
"positional quotient transformation (x/median)" = "n9a",
"quotient transformation (x/sum)" = "n10",
"quotient transformation (x/sqrt(SSQ))" = "n11",
"normalization ((x-mean)/sqrt(sum((x-mean)^2)))" = "n12",
"positional normalization ((x-median)/sqrt(sum((x-median)^2)))" = "n12a",
"normalization with zero being the central point ((x-midrange)/(range/2))" = "n13")
),
radioButtons("type", label = "Type",
choices = list("Column" = "column", "Row" = "row")
)
)
)
})
#obtengo el tipo de normalizacion seleccionada y aplico la normalizacion correspondiente
normalization_type <- reactive({
if (is.null(input$normalizationType))
return()
switch(input$normalizationType,
'1'=  withProgress({
setProgress(message = "This may take a while...")
normalizeData(missingV())
}),
'2'=  withProgress({
setProgress(message = "This may take a while...")
normalizeData(missingV(), input$min, input$max)
}),
'3'=  withProgress({
setProgress(message = "This may take a while...")
data.Normalization(missingV(),type=input$type_normalization ,normalization= input$type)
})
)
})
#muestro los primeros 10 atributos del data set original
output$original_data <- renderPrint({#renderDataTable(
missingV()[1:10,]
#options = list(paging = FALSE, searching = FALSE)
})
#muestro os primeros 10 atributos del data set normalizado
output$normalized_data <- renderPrint({#renderDataTable(
normalization_type()[1:10,]
#options = list(paging = FALSE, searching = FALSE)
})
#muestro un sumary
output$summary_normalization <- renderPrint({#renderDataTable(
summary(normalization_type())
#options = list(paging = FALSE, searching = FALSE)
})
#************************************************
#-------------> Reduccion de la dimencionalidad
#Slider visualizacion grafico PCA
output$slider_range_range_pca <- renderUI({
twoSlider("attributes3","observation3",missingV(),"Attributes",strz)
})
#Obtengo la seleccion de atributos y observaciones para pca
selectedDataPCA <- reactive({
missingV()[input$observation3[1]:input$observation3[2],
input$attributes3[1]:input$attributes3[2]]
})
pca <- reactive({
prcomp(selectedDataPCA(), center = TRUE, scale. = TRUE)
})
pcaGrafic <- function(){
if(is.null(input$attributes3) || is.na(input$attributes3)){
return()
}
withProgress({
setProgress(message = "This may take a while...")
elbowPlot(pca())
})
}
#grafico de PCA
output$pca <- renderPlot({
tryCatch({
pcaGrafic()
}, error = function(e) {
createAlert(session, "alertPCA", "alertPCAID", title = titleAlert,
content = paste("",e),
style = "warning")
})
})
#-------------->dowload image plot
observe({
output$downloadPlotpca <- downloadGeneral(input$radiopca, pcaGrafic())
})
#Informacion resumen de los pc's obtenidos
output$summary_pcs <- renderPrint({
summary(pca())
})
reduceDimensionality <- reactive({
if(input$reduceDim){
selectedDataPCA()
}
else
missingV()
})
output$summary_reduceDimensionality <- renderPrint({
summary(reduceDimensionality())
})
#------------SVD
s <- reactive({
dat <- as.matrix(missingV())
svd(dat)
})
#grafico para SVD
output$svd <- renderPlot({
withProgress({
setProgress(message = "This may take a while...")
plot(cumsum(s()$d^2/sum(s()$d^2)))
})
})
output$s <- renderPrint({
s()$d
})
#-------------------------------------------------------
#-----------------------> Train <-----------------------
#-----------------------> validation type
#salida dinamica para solicitar unn archivo o un % para particionar
output$testFile <- renderUI({
if (is.null(input$select_validation))
return()
switch(input$select_validation,
'2' = fileInput('fileTest', 'Test File',
accept=c('text/csv', 'text/comma-separated-values,text/plain','.csv')),
'3' = numericInput("porcentTest", "Train size in %", 0.75,
min = 0.0, max = 1, step = 0.02)
)
})
#particion en porcentaje de train y test
train_ind <- function(){
dataset <- data.frame(reduceDimensionality())
smp_size <- floor(input$porcentTest * nrow(dataset))
set.seed(123)
sample(seq_len(nrow(dataset)), size = smp_size)
#     train <- dataset[train_ind, ]
#     test <- dataset[-train_ind, ]
#     return(list(train, test))
}
#-----------------------> lm
#seleccion de la variable dependiente
output$select_box_lm_y <- renderUI({
numVariables <- dim(reduceDimensionality())[2]
namesVariables <- names(reduceDimensionality())
selectInput("lm_y", label = h4("Dependent variable"),
choices = namesVariables, selected = names(reduceDimensionality())[numVariables])
})
#seleccion de la variable independiente
output$select_box_lm_x <- renderUI({
selectInput("lm_x", label = h4("Independent variable"),
choices = names(reduceDimensionality()), multiple = TRUE)
})
#Aplicando el modelo lm
fit <- reactive({
if(is.null(input$lm_x)){
(fmla <- as.formula(paste(paste(input$lm_y, " ~ "), ".")))
}
#input$lm_y
else
(fmla <- as.formula(paste(paste(input$lm_y, " ~ "), paste(input$lm_x, collapse= "+"))))
if (is.null(input$select_validation))
return()
switch (input$select_validation,
'1' = lm(fmla, data=reduceDimensionality()),
'3' = lm(Sepal.Length ~ ., data = data.frame(
reduceDimensionality()[train_ind(), ]))
)
#lm(fmla, data=reduceDimensionality())
})
#Resultado obtenido tras aplicar el  modelo
output$summary_lm <- renderPrint({
withProgress({
setProgress(message = "This may take a while...")
summary(fit())
})
})
validation <- reactive({
if (is.null(input$select_validation))
return()
switch(input$select_validation,
'1' = CVlm(reduceDimensionality(), fit(), m=10), # ten-fold cross validation
'3' = predict(fit(), data.frame(reduceDimensionality()[-train_ind(), ]))
)
})
output$resulValidation <- renderPrint({
validation()
})
#-------------------------------------------------------
#-----------------------> outlier <-----------------------
#-----------------------> Diagnostic Plots
diagnostic <- reactive({
diagnosticData(fit())
})
#funcion para el grafico residual vs fitted
plotRF <- function(){
myPalette <- c(input$col1, input$col2, input$col3)
withProgress({
setProgress(message = "This may take a while...")
ResidualsFitted(diagnostic(), input$lm_y, colours = myPalette)
})
}
#visualizacion del grafico residual vs fitted
output$ResidualsFitted <- renderPlot({
tryCatch({
plotRF()
}, error = function(e) {
createAlert(session, "alertRF", "alertRFID", title = titleAlert,
content = paste("",e), style = "warning")
})
})
#muestra informacion de los puntos seleccionados
output$ResidualsFitted_brushInfo <- renderPrint({
brushedPoints(diagnostic(), input$ResidualsFitted_brush)[1:dim(reduceDimensionality())[2]]
})
#-------------->dowload image plot
observe({
output$downloadPlotRF <- downloadGeneral(input$radioRF, plotRF())
})
#funcion para el grafico Standarized Residuals v/s Fitted Values
plotSF <- function(){
myPalette <- c(input$col1, input$col2, input$col3)
withProgress({
setProgress(message = "This may take a while...")
StResidualsFitted(diagnostic(), input$lm_y, colours = myPalette)
})
}
#vista de grafico Standarized Residuals v/s Fitted Values
output$StResidualsFitted <- renderPlot({
tryCatch({
plotSF()
}, error = function(e) {
createAlert(session, "alertSF", "alertSFID", title = titleAlert,
content = paste("",e), style = "warning")
})
})
#muestra informacion de los puntos seleccionados
output$StResidualsFitted_brushInfo <- renderPrint({
brushedPoints(diagnostic(), input$StResidualsFitted_brush)[1:dim(reduceDimensionality())[2]]
})
#-------------->dowload image plot
observe({
output$downloadPlotSF <- downloadGeneral(input$radioSF, plotSF())
})
#funcion para el grafico normal Q-Q
plotQQ <- function(){
withProgress({
setProgress(message = "This may take a while...")
NormalQQ(diagnostic(), input$lm_y)
})
}
#visualizacion del grafico normal Q-Q
output$NormalQQ <- renderPlot({
tryCatch({
plotQQ()
}, error = function(e) {
createAlert(session, "alertQQ", "alertQQID", title = titleAlert,
content = paste("",e), style = "warning")
})
})
#   #muestra informacion de los puntos seleccionados
#   output$NormalQQ_brushInfo <- renderPrint({
#     brushedPoints(diagnostic(), input$NormalQQ_brush)[1:dim(reduceDimensionality())[2]]
#   })
#-------------->dowload image plot
observe({
output$downloadPlotQQ <- downloadGeneral(input$radioQQ, plotQQ())
})
#funcion para el grafico residual vs leverage
plotRL <- function(){
myPalette <- c(input$col1, input$col2, input$col3)
withProgress({
setProgress(message = "This may take a while...")
StResidualsLeverange(diagnostic(), input$lm_y, colours = myPalette)
})
}
#visualizacion del grafico residual vs leverage
output$StResidualsLeverange <- renderPlot({
tryCatch({
plotRL()
}, error = function(e) {
createAlert(session, "alertRL", "alertRLID", title = titleAlert,
content = paste("",e), style = "warning")
})
})
#muestra informacion de los puntos seleccionados
output$StResidualsLeverange_brushInfo <- renderPrint({
brushedPoints(diagnostic(), input$StResidualsLeverange_brush)[1:dim(reduceDimensionality())[2]]
})
#-------------->dowload image plot
observe({
output$downloadPlotRL <- downloadGeneral(input$radioRL, plotRL())
})
}
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
