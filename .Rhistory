only_file_nums()
})
#Slider visualizacion grafico de missing values Amelia
output$slider_range_range_amelia <- renderUI({
box(
width = 6, status = "success",
h4("Range"),
sliderInput("attributes", label = "Attributes", min = 1,
max = dim(missingV())[2], value = c(1,4)),
sliderInput("observation", label = strz, min = 1,
max = dim(missingV())[1], value = c(1, (dim(missingV())[1])/2))
)
})
#Obtengo la seleccion de atributos y observaciones para la Opcion 1
selectedData1 <- reactive({
missingV()[input$observation[1]:input$observation[2],
input$attributes[1]:input$attributes[2]]
})
#Opcion 1 (libreria Amelia)
output$missing1 <- renderPlot({
if(is.null(input$attributes) || is.na(input$attributes)){
return()
}
missmap(selectedData1(), main = "Missing values vs observed")
})
#   #---------descarga del grafico opcion 1
# #   downloadInput <- reactive({
# #     switch(input$radio,
# #            '1' = '.png',
# #            '2' = '.svg',
# #            '3' = '.pdf')
# #   })
#
#Slider visualizacion grafico de missing VIM option1
output$slider_range_range_option1 <- renderUI({
box(
width = 6, status = "success",
h4("Range"),
sliderInput("attributes2", label = "Attributes", min = 1,
max = dim(missingV())[2], value = c(1, 4)),
sliderInput("observation2", label = strz, min = 1,
max = dim(missingV())[1], value = c(1, (dim(missingV())[1])/2))
)
})
#Obtengo la seleccion de atributos y observaciones para la Opcion 2
selectedData2 <- reactive({
missingV()[input$observation2[1]:input$observation2[2],
input$attributes2[1]:input$attributes2[2]]
})
#Opcion 2 (libreria VIM)
output$missing2 <- renderPlot({
if(is.null(input$attributes2) || is.na(input$attributes2)){
return()
}
aggr(selectedData2(), col=c('red','dark grey'), numbers=TRUE,
sortVars=TRUE, labels=names(data), cex.axis=.8, gap=1,
ylab=c("Histogram of missing data","Pattern"))
})
#Slider visualizacion grafico de missing VIM option2
output$slider_range_range_option2 <- renderUI({
box(
width = 6, status = "success",
h4("Range"),
sliderInput("x3", label = strx, min = 1,
max = dim(missingV())[2], value = c(1, 4)),
sliderInput("y3", label = stry, min = 1,
max = dim(missingV())[2], value = 2),
sliderInput("z3", label = strz, min = 1,
max = dim(missingV())[1], value = c(1, dim(missingV())[1]))
)
})
#Obtengo la seleccion de atributos a comparar para la Opcion 3
dat3 <- reactive({
missingV()[input$z3[1]:input$z3[2],input$x3[1]:input$x3[2]]
})
#Option 3 (matricial)
output$missing3 <- renderPlot({
if(is.null(input$x3) || is.na(input$x3)){
return()
}
scattmatrixMiss(dat3(), interactive = F, highlight = c(names(missingV())[[input$y3]]))
})
#************************************************
#-------------> Normalization
#salida dinamica de rango para normalizacion
output$range <- renderUI({
if (is.null(input$normalizationType))
return()
switch(input$normalizationType,
'2' =  tags$div( class = 'col-sm-8',
tags$div( class = 'col-sm-4',
numericInput("min", label = "Min", value = 0)
),
tags$div( class = 'col-sm-4',
numericInput("max", label = "Max", value = 1)
)
),
'3'= tags$div( class = 'col-sm-8',
selectInput("type_normalization", label = "Other normalization",
choices = list("without normalization" = "n0",
"standardization ((x-mean)/sd)" = "n1",
"positional standardization ((x-median)/mad)" = "n2",
"unitization ((x-mean)/range)" = "n3",
"positional unitization ((x-median)/range)" = "n3a",
"unitization with zero minimum ((x-min)/range)" = "n4",
"normalization in range <-1,1> ((x-mean)/max(abs(x-mean)))" = "n5",
"positional normalization in range <-1,1> ((x-median)/max(abs(x-median)))" = "n5a",
"quotient transformation (x/sd)" = "n6",
"positional quotient transformation (x/mad)" = "n6a",
"quotient transformation (x/range)" = "n7",
"quotient transformation (x/max)" = "n8",
"quotient transformation (x/mean)" = "n9",
"positional quotient transformation (x/median)" = "n9a",
"quotient transformation (x/sum)" = "n10",
"quotient transformation (x/sqrt(SSQ))" = "n11",
"normalization ((x-mean)/sqrt(sum((x-mean)^2)))" = "n12",
"positional normalization ((x-median)/sqrt(sum((x-median)^2)))" = "n12a",
"normalization with zero being the central point ((x-midrange)/(range/2))" = "n13")
),
radioButtons("type", label = "Type",
choices = list("Column" = "column", "Row" = "row")
)
)
)
})
#obtengo el tipo de normalizacion seleccionada y aplico la normalizacion correspondiente
normalization_type <- reactive({
if (is.null(input$normalizationType))
return()
switch(input$normalizationType,
'1'= normalizeData(missingV()),
'2'= normalizeData(missingV(), input$min, input$max),
'3'= data.Normalization(missingV(),type=input$type_normalization ,normalization= input$type)
)
})
#muestro los primeros 10 atributos del data set original
output$original_data <- renderPrint({#renderDataTable(
missingV()[1:10,]
#options = list(paging = FALSE, searching = FALSE)
})
#muestro os primeros 10 atributos del data set normalizado
output$normalized_data <- renderPrint({#renderDataTable(
normalization_type()[1:10,]
#options = list(paging = FALSE, searching = FALSE)
})
#muestro un sumary
output$summary_normalization <- renderPrint({#renderDataTable(
summary(normalization_type())
#options = list(paging = FALSE, searching = FALSE)
})
#************************************************
#-------------> Reduccion de la dimencionalidad
#Slider visualizacion grafico PCA
output$slider_range_range_pca <- renderUI({
box(
width = 6, status = "success",
h4("Range"),
sliderInput("attributes3", label = "Attributes", min = 1,
max = dim(missingV())[2], value = c(1, 4)),
sliderInput("observation3", label = strz, min = 1,
max = dim(missingV())[1], value = c(1, (dim(missingV())[1])/2))
)
})
#Obtengo la seleccion de atributos y observaciones para pca
selectedDataPCA <- reactive({
missingV()[input$observation3[1]:input$observation3[2],
input$attributes3[1]:input$attributes3[2]]
})
pca <- reactive({
prcomp(selectedDataPCA(), center = TRUE, scale. = TRUE)
})
#grafico de PCA
output$pca <- renderPlot({
if(is.null(input$attributes3) || is.na(input$attributes3)){
return()
}
elbowPlot(pca())
})
#Informacion resumen de los pc's obtenidos
output$summary_pcs <- renderPrint({
summary(pca())
})
reduceDimensionality <- reactive({
if(input$reduceDim){
selectedDataPCA()
}
else
missingV()
})
output$summary_reduceDimensionality <- renderPrint({
summary(reduceDimensionality())
})
#------------SVD
s <- reactive({
dat <- as.matrix(missingV())
svd(dat)
})
#grafico para SVD
output$svd <- renderPlot({
plot(cumsum(s()$d^2/sum(s()$d^2)))
})
output$s <- renderPrint({
s()$d
})
#************************************************
#-------------> Eliminacion de ruido
#Slider visualizacion grafico ruido
output$slider_range_range_nremoval <- renderUI({
box(
width = 6, status = "success",
h4("Range"),
sliderInput("attributes4", label = "Attributes", min = 1,
max = dim(missingV())[2], value = c(1, 4)),
sliderInput("observation4", label = strz, min = 1,
max = dim(missingV())[1], value = c(1, (dim(missingV())[1])/2))
)
})
#Obtengo la seleccion de atributos y observaciones para grafico ruido
selectedDataNremoval <- reactive({
missingV()[input$observation4[1]:input$observation4[2],
input$attributes4[1]:input$attributes4[2]]
})
#grafico de ruido
output$nremoval <- renderPlot({
#iris.x <- iris[,1:4]
ir.pca <- prcomp(selectedDataNremoval(), center = TRUE, scale. = TRUE)
elbowPlot(ir.pca)
})
#************************************************
#-------------> Outlier
output$rsidualFitted <- renderImage({
list(
src = "images/residual_f.png",
contentType = 'image/png',
width = 400,
height = 400,
alt = "Home")
}, deleteFile = FALSE)
output$sacaleLocation <- renderImage({
list(
src = "images/scale.png",
contentType = 'image/png',
width = 400,
height = 400,
alt = "Home")
}, deleteFile = FALSE)
output$normalQQ <- renderImage({
list(
src = "images/normal.png",
contentType = 'image/png',
width = 400,
height = 400,
alt = "Home")
}, deleteFile = FALSE)
output$residualLeverage <- renderImage({
list(
src = "images/residual_l.png",
contentType = 'image/png',
width = 400,
height = 400,
alt = "Home")
}, deleteFile = FALSE)
#-------------------------------------------------------
#-----------------------> Train <-----------------------
#-----------------------> lm
#seleccion de la variable dependiente
output$select_box_lm_y <- renderUI({
numVariables <- dim(reduceDimensionality())[2]
namesVariables <- names(reduceDimensionality())
selectInput("lm_y", label = h4("Dependent variable"),
choices = namesVariables, selected = names(reduceDimensionality())[numVariables])
})
#seleccion de la variable independiente
output$select_box_lm_x <- renderUI({
selectInput("lm_x", label = h4("Independent variable"),
choices = names(reduceDimensionality()), multiple = TRUE)
})
#Aplicando el modelo lm
fit <- reactive({
if(is.null(input$lm_x)){
(fmla <- as.formula(paste(paste(input$lm_y, " ~ "), ".")))
}
#input$lm_y
else
(fmla <- as.formula(paste(paste(input$lm_y, " ~ "), paste(input$lm_x, collapse= "+"))))
lm(fmla, data=reduceDimensionality())
})
#Resultado obtenido tras aplicar el  modelo
output$summary_lm <- renderPrint({
summary(fit())
})
#-------------------------------------------------------
#-----------------------> outlier <-----------------------
#-----------------------> Diagnostic Plots
#Slider visualizacion grafico residual vs fitted
output$slider_outlier_residualF <- renderUI({
box(
width = 6, status = "success",
h4("Range"),
sliderInput("attributes4", label = "Attributes", min = 1,
max = dim(reduceDimensionality())[2], value = c(1, 4)),
sliderInput("observation4", label = strz, min = 1,
max = dim(reduceDimensionality())[1], value = c(1, (dim(reduceDimensionality())[1])/2))
)
})
#Obtengo la seleccion de atributos y observaciones para grafico residual vs fitted
selectedDataResidualF <- reactive({
diagnostic <- diagnosticData(fit())
diagnostic[input$observation4[1]:input$observation4[2],
input$attributes4[1]:input$attributes4[2]]
})
#grafico de grafico residual vs fitted
output$ResidualsFitted <- renderPlot({
if(is.null(input$attributes4) || is.na(input$attributes4)){
return()
}
ResidualsFitted(selectedDataResidualF(), "Ozone")
})
}
#App
shinyApp(ui, server)
shiny::runApp('~/GitHub/Shiny')
setwd("~/GitHub/Shiny")
shiny::runApp()
source('funciones/opcionesDashboard.r')
source('funciones/preprocessing.r')
source('funciones/transformation.r')
source('preprocessing.r')
setwd("~/GitHub/Shiny/funciones")
source('preprocessing.r')
source('funciones/transformation.r')
source("funciones/transformation.r")
source("funciones/transformation.r")
source('funciones/opcionesDashboard.r')
setwd("~/GitHub/Shiny")
source('funciones/opcionesDashboard.r')
source('funciones/preprocessing.r')
source("funciones/transformation.r")
source("funciones/data.r")
source("funciones/data.r")
source('funciones/regresion.r')
source('funciones/outlier.r')
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
iris.x <- iris[,1:4]
Species <- iris[,5]
ScatterplotMatrix(iris.x, c(1,2,3,4), Species, "Species")
ScatterplotMatrix(iris.x, c(2,4), Species, "Species", 2, 1)
ScatterplotMatrix(iris.x, c(2,4), Species, "Species", 2, 2)
ScatterplotMatrix(iris.x, c(2,4), Species, "Species", 1, 1)
shiny::runApp()
ScatterplotMatrix(iris.x, c(2,4), Species, "Species", 1, 0.5)
install_github("mariytu/RegressionLibs") #Para usar esto hay que tener instalado devtools
library(devtools)
install.packages("devtools")
install.packages("devtools")
library(devtools)
install_github("mariytu/RegressionLibs") #Para usar esto hay que tener instalado devtools
library('RegressionLibs')
devtools::install_github("daattali/shinyjs") #libreria para los colores
library(shinyjs)
dat <- data.frame(matrix(rnorm(120, 2, 3), ncol=3))
runApp(shinyApp(
ui = fluidPage(
uiOutput('myPanel'),
plotOutput("plot")
),
server = function(input, output, session) {
cols <- reactive({
lapply(seq_along(dat), function(i) {
colourInput(paste("col", i, sep="_"), "Choose colour:", "black")
})
})
output$myPanel <- renderUI({cols()})
# Put all the input in a vector
colors <- reactive({
lapply(seq_along(dat), function(i) {
input[[paste("col", i, sep="_")]]
})
})
output$plot <- renderPlot({
if (is.null(input$col_1)) {
cols <- rep("#000000", ncol(dat))
} else {
cols <- unlist(colors())
}
plot(dat[,1], col = cols[1])
for(i in 2:ncol(dat)) lines(dat[,i], col = cols[i])
})
}
))
dat <- data.frame(matrix(rnorm(120, 2, 3), ncol=3))
ui <- fluidPage(
uiOutput('myPanel'),
plotOutput("plot")
),
server <- function(input, output, session) {
cols <- reactive({
lapply(seq_along(dat), function(i) {
colourInput(paste("col", i, sep="_"), "Choose colour:", "black")
})
})
output$myPanel <- renderUI({cols()})
# Put all the input in a vector
colors <- reactive({
lapply(seq_along(dat), function(i) {
input[[paste("col", i, sep="_")]]
})
})
output$plot <- renderPlot({
if (is.null(input$col_1)) {
cols <- rep("#000000", ncol(dat))
} else {
cols <- unlist(colors())
}
plot(dat[,1], col = cols[1])
for(i in 2:ncol(dat)) lines(dat[,i], col = cols[i])
})
}
shinyApp(ui, server)
library(shiny)
library(shinyjs)
dat <- data.frame(matrix(rnorm(120, 2, 3), ncol=3))
runApp(shinyApp(
ui = fluidPage(
uiOutput('myPanel'),
plotOutput("plot")
),
server = function(input, output, session) {
cols <- reactive({
lapply(seq_along(dat), function(i) {
colourInput(paste("col", i, sep="_"), "Choose colour:", "black")
})
})
output$myPanel <- renderUI({cols()})
# Put all the input in a vector
colors <- reactive({
lapply(seq_along(dat), function(i) {
input[[paste("col", i, sep="_")]]
})
})
output$plot <- renderPlot({
if (is.null(input$col_1)) {
cols <- rep("#000000", ncol(dat))
} else {
cols <- unlist(colors())
}
plot(dat[,1], col = cols[1])
for(i in 2:ncol(dat)) lines(dat[,i], col = cols[i])
})
}
))
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
iris.x <- iris[,1:4] # These are the independent variables
Species <- iris[,5]
myPalette <- c("darkolivegreen4", "goldenrod1", "dodgerblue4")
ScatterplotMatrix(iris.x, c(2,4), Species, "Species", colours = myPalette)
shiny::runApp()
shiny::runApp()
myPalette <- c("#FFFFFF", "#FF0000", "#00FF00")
ScatterplotMatrix(iris.x, c(2,4), Species, "Species", colours = myPalette)
lapply(seq_along(dat), function(i) {
input[[paste("col", i, sep="_")]]
})
shiny::runApp()
shiny::runApp()
shiny::runApp()
library(shiny)
library(shinyjs)
dat <- data.frame(matrix(rnorm(120, 2, 3), ncol=3))
runApp(shinyApp(
ui = fluidPage(
strong("Selected colour:", textOutput("value", inline = TRUE)),
colourInput("col", "Choose colour", "red"),
h3("Update colour input"),
textInput("text", "New colour: (colour name or HEX value)"),
selectInput("showColour", "Show colour",
c("both", "text", "background")),
selectInput("palette", "Colour palette",
c("square", "limited")),
checkboxInput("allowTransparent", "Allow transparent", FALSE),
actionButton("btn", "Update")
),
server = function(input, output, session) {
observeEvent(input$btn, {
updateColourInput(session, "col",
value = input$text, showColour = input$showColour,
allowTransparent = input$allowTransparent,
palette = input$palette)
})
output$value <- renderText(input$col)
}
))
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
